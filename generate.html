<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>The Mythical Cursed-Nightmare: Essays on Generative Tragedy</title>

    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="favicon.svg" />
    <link rel="alternate icon" href="favicon.svg" />

    <!-- Apple Touch Icon (180x180 for iOS) -->
    <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.svg" />
    
    <!-- PWAÂØæÂøú -->
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <!-- Additional Meta Tags -->
    <meta name="theme-color" content="#6B46C1" />
    <meta
      name="description"
      content="The Mythical Cursed-Nightmare - Essays on Generative Tragedy. Discover legendary tales and hidden tragedies in this NFT collection."
    />

    <link rel="stylesheet" href="css/styles.css" />
    <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  </head>
  <body>
    <div class="container">
      <h1>The Mythical Cursed-Nightmare</h1>
      <p
        style="
          font-size: 15px;
          color: #ddd;
          margin-top: 4px;
          text-align: center;
          font-weight: 500;
        "
      >
        Essays on Generative Tragedy
      </p>
      <p
        style="
          font-size: 13px;
          color: #666;
          margin-top: 4px;
          text-align: center;
        "
      >
        Discover legendary tales and hidden tragedies.
      </p>

      <div class="button-group">
        <button onclick="generateSingle()">Generate</button>
        <button
          onclick="window.location.href='story.html'"
          style="background: linear-gradient(45deg, #7b2d43, #9b1b5a)"
        >
          Narrative
        </button>
        <button onclick="window.location.href='essays.html'" class="nav-button">
          Collection
        </button>
      </div>


      <div id="metadataDisplay" class="metadata-display"></div>

      <div class="id-controls">
        <div class="id-controls-inner">
          <input
            type="number"
            id="idInput"
            placeholder="ID"
            min="1"
            max="10000"
          />
          <button onclick="generateById()" class="generate-button">
            Generate
          </button>
          <div class="nav-buttons">
            <button onclick="generatePrev()" class="nav-button">Prev</button>
            <button onclick="generateNext()" class="nav-button">Next</button>
          </div>
        </div>
      </div>

      <div class="legendary-ids">
        <h3>üî• Legendary IDs</h3>
        <div class="legendary-ids-list">
          <button class="legendary-id-button" onclick="generateSpecificId(666)">
            666 - The Beast
          </button>
          <button
            class="legendary-id-button"
            onclick="generateSpecificId(1337)"
          >
            1337 - The Chosen
          </button>
          <button
            class="legendary-id-button"
            onclick="generateSpecificId(9999)"
          >
            9999 - Final Guardian
          </button>
          <button class="legendary-id-button" onclick="generateSpecificId(404)">
            404 - Lost Soul
          </button>
          <button
            class="legendary-id-button"
            onclick="generateSpecificId(7777)"
          >
            7777 - Fortune's Avatar
          </button>
          <button class="legendary-id-button" onclick="generateSpecificId(13)">
            13 - The Cursed
          </button>
          <button
            class="legendary-id-button"
            onclick="generateSpecificId(1000)"
          >
            1000 - The Millennial
          </button>
          <button class="legendary-id-button" onclick="generateSpecificId(42)">
            42 - The Answer
          </button>
        </div>
      </div>

      <footer
        style="
          text-align: center;
          margin-top: 40px;
          padding-top: 20px;
          color: #c084fc;
          font-size: 14px;
        "
      >
        ¬© 2025 The Mythical Cursed-Nightmare
        <a
          href="http://bon-soleil.com"
          target="_blank"
          rel="noopener noreferrer"
          style="color: #c084fc; text-decoration: none; transition: color 0.3s"
          onmouseover="this.style.color='#E9D5FF'"
          onmouseout="this.style.color='#C084FC'"
          >bonsoleil</a
        >
      </footer>
    </div>

    <script>
      let currentMetadata = [];
      let provider;
      let metadataBank;
      let blockchainConfig = null;
      
      // Load blockchain configuration
      async function loadBlockchainConfig() {
        try {
          const response = await fetch('config/blockchain.json');
          if (response.ok) {
            blockchainConfig = await response.json();
            console.log('Blockchain configuration loaded');
            return true;
          }
        } catch (error) {
          console.log('Failed to load blockchain config, using defaults');
        }
        
        // Fallback configuration - Ê≠£„Åó„ÅÑ„Ç¢„Éâ„É¨„Çπ„Çí‰ΩøÁî®
        blockchainConfig = {
          networks: {
            bonsoleil: {
              name: "Bon-Soleil Testnet",
              rpcUrl: "https://dev2.bon-soleil.com/rpc",
              contracts: {
                metadataBank: {
                  address: "0x446697246d89Ac256a48359a5b6DeAEb29D192Db", // Ê≠£„Åó„ÅÑ„Ç¢„Éâ„É¨„Çπ
                  abi: [
                    "function getMetadataCount() view returns (uint256)",
                    "function getMetadata(uint256 index) view returns (string)",
                    "function composer() view returns (address)",
                    "function decodeTokenId(uint256 tokenId) view returns (uint8 species, uint8 background, uint8 item, uint8 effect)",
                    "function generateMetadata(uint256 tokenId, uint8 species, uint8 background, uint8 item, uint8 effect) view returns (string)"
                  ]
                }
              }
            }
          },
          defaultNetwork: "bonsoleil"
        };
        return true;
      }
      
      // Initialize blockchain connection
      async function initBlockchain() {
        try {
          if (typeof ethers === 'undefined') {
            alert('ethers.js library not loaded. Please check your internet connection.');
            return false;
          }
          
          // Load configuration first
          await loadBlockchainConfig();
          
          const network = blockchainConfig.networks[blockchainConfig.defaultNetwork];
          if (!network) {
            console.error('Network configuration not found');
            return false;
          }
          
          provider = new ethers.providers.JsonRpcProvider(network.rpcUrl);
          await provider.ready;
          
          const metadataBankConfig = network.contracts.metadataBank;
          console.log('Using MetadataBank configuration:', metadataBankConfig);
          
          // ÊòéÁ§∫ÁöÑ„Å´„Ç¢„Éâ„É¨„Çπ„ÇíÁ¢∫Ë™ç
          const contractAddress = metadataBankConfig.address;
          console.log(`Creating contract instance with address: ${contractAddress}`);
          
          metadataBank = new ethers.Contract(contractAddress, metadataBankConfig.abi, provider);
          
          console.log(`Connected to ${network.name || 'Network'} at ${network.rpcUrl}`);
          console.log(`MetadataBank address: ${contractAddress}`);
          
          // Test connection - but don't fail if getMetadataCount doesn't work
          try {
            const count = await metadataBank.getMetadataCount();
            console.log('MetadataBank total metadata:', count.toString());
          } catch (error) {
            console.log('getMetadataCount not available, but contract may still work');
          }
          
          return true;
        } catch (error) {
          console.error('Failed to connect to blockchain:', error);
          return false;
        }
      }
      
      // Generate metadata from blockchain
      async function generateMetadataFromBlockchain(id) {
        try {
          
          // Get metadata from blockchain
          const index = (id - 1) % 10000; // Convert ID to index (0-based)
          let metadataUri = await metadataBank.getMetadata(index);
          
          // Check if the result is an address (proxy pattern)
          if (metadataUri.startsWith('0x') && metadataUri.length === 42) {
            console.log('MetadataBank returned an address, likely a proxy pattern:', metadataUri);
            // Try using the returned address as a new metadata bank
            const proxyMetadataBank = new ethers.Contract(
              metadataUri, 
              blockchainConfig.networks[blockchainConfig.defaultNetwork].contracts.metadataBank.abi, 
              provider
            );
            
            try {
              metadataUri = await proxyMetadataBank.getMetadata(index);
            } catch (proxyError) {
              console.error('Failed to get metadata from proxy contract:', proxyError);
              throw proxyError;
            }
          }
          
          // Decode the metadata
          if (metadataUri.startsWith('data:application/json;base64,')) {
            const base64Json = metadataUri.replace('data:application/json;base64,', '');
            const jsonString = atob(base64Json);
            const metadata = JSON.parse(jsonString);
            
            console.log('Fetched metadata from blockchain:', metadata);
            return metadata;
          } else if (metadataUri.startsWith('{')) {
            // Plain JSON string
            const metadata = JSON.parse(metadataUri);
            console.log('Fetched metadata from blockchain:', metadata);
            return metadata;
          }
          
          throw new Error('Invalid metadata format: ' + metadataUri.substring(0, 50));
        } catch (error) {
          console.error('Error fetching from blockchain:', error);
          alert('Error loading NFT data from blockchain. Please try again.');
          throw error;
        }
      }

      // Generate single random NFT
      async function generateSingle() {
        const id = Math.floor(Math.random() * 10000) + 1;
        
        if (!metadataBank) {
          alert('Blockchain connection not available. Please refresh the page.');
          return;
        }
        
        try {
          const metadata = await generateMetadataFromBlockchain(id);
          currentMetadata = [metadata];
          displayMetadata(currentMetadata);
        } catch (error) {
          console.error('Failed to generate NFT:', error);
        }
      }


      // Generate specific legendary ID
      async function generateSpecificId(id) {
        document.getElementById("idInput").value = id;
        await generateById();
      }

      // Generate NFT by specific ID
      async function generateById() {
        const idInput = document.getElementById("idInput");
        const id = parseInt(idInput.value);

        if (!id || id < 1 || id > 10000) {
          alert("Please enter a valid ID between 1 and 10000");
          return;
        }
        
        if (!metadataBank) {
          alert('Blockchain connection not available. Please refresh the page.');
          return;
        }

        try {
          const metadata = await generateMetadataFromBlockchain(id);
          currentMetadata = [metadata];
          displayMetadata(currentMetadata);
        } catch (error) {
          console.error('Failed to generate NFT:', error);
        }
      }

      // Navigate to next ID
      async function generateNext() {
        const idInput = document.getElementById("idInput");
        const currentId = parseInt(idInput.value) || 0;
        let nextId = currentId + 1;
        if (nextId > 10000) nextId = 1;

        idInput.value = nextId;
        await generateById();
      }

      // Navigate to previous ID
      async function generatePrev() {
        const idInput = document.getElementById("idInput");
        const currentId = parseInt(idInput.value) || 1;
        let prevId = currentId - 1;
        if (prevId < 1) prevId = 10000;

        idInput.value = prevId;
        await generateById();
      }

      // Copy text to clipboard
      function copyToClipboard(text, button) {
        navigator.clipboard
          .writeText(text)
          .then(() => {
            const originalText = button.textContent;
            button.textContent = "Copied!";
            setTimeout(() => {
              button.textContent = originalText;
            }, 2000);
          })
          .catch((err) => {
            console.error("Failed to copy:", err);
          });
      }

      // Display metadata
      function displayMetadata(metadataArray) {
        const display = document.getElementById("metadataDisplay");
        display.innerHTML = "";
        display.className = "metadata-display show";

        // Since we only display one metadata at a time, use the first one
        const metadata = metadataArray[0];
        if (!metadata) return;

        // Check for special attributes
        const isSpecial = metadata.attributes.find(
          (a) => a.trait_type === "Special"
        );
        const isLegendary = metadata.attributes.find(
          (a) => a.trait_type === "Legendary"
        );
        const rarity =
          metadata.attributes.find((a) => a.trait_type === "Rarity")?.value ||
          "Common";

        // Add rarity class
        if (rarity === "Legendary") display.classList.add("rarity-legendary");
        else if (rarity === "Epic") display.classList.add("rarity-epic");
        else if (rarity === "Rare") display.classList.add("rarity-rare");

        // Extract ID from name
        const idMatch = metadata.name.match(/#(\d+)$/);
        const nftId = idMatch ? idMatch[1] : "1";
        const metadataUrl = `${window.location.origin}${window.location.pathname}api.php?id=${nftId}`;

        // Build attributes HTML
        const attributesHtml = metadata.attributes
          .map(
            (attr) => `
                <div class="attribute">
                    <div class="attribute-type">${attr.trait_type}</div>
                    <div class="attribute-value">${attr.value}</div>
                </div>
            `
          )
          .join("");

        // Format JSON
        const jsonString = JSON.stringify(metadata, null, 2);

        // Build badges
        let badgesHtml = "";
        if (isLegendary) {
          badgesHtml +=
            '<span class="special-badge legendary-badge">‚ö° LEGENDARY ID</span>';
        }
        if (isSpecial) {
          badgesHtml += '<span class="special-badge">‚ú® SPECIAL COMBO</span>';
        }

        // Build HTML
        display.innerHTML = `
                <img src="${metadata.image}" alt="${
          metadata.name
        }" class="metadata-image">
                <div class="metadata-header">
                    ${badgesHtml}
                </div>
                <div class="metadata-name">${metadata.name}</div>
                <div class="metadata-description">"${
                  metadata.description
                }"</div>
                <div class="attributes">${attributesHtml}</div>
                <div class="json-container">
                    <div class="json-toggle" onclick="toggleJson(this)">
                        <span class="toggle-icon">‚ñ∂</span> View JSON
                        <div>
                            <button class="copy-json-button" onclick="event.stopPropagation(); copyToClipboard(\`${jsonString.replace(
                              /`/g,
                              "\\`"
                            )}\`, this)">Copy</button>
                            <button class="copy-json-button" onclick="event.stopPropagation(); downloadSingle(${JSON.stringify(
                              metadata
                            ).replace(/"/g, "&quot;")})">Download</button>
                        </div>
                    </div>
                    <div class="json-display" style="display: none;">
                        <pre>${jsonString}</pre>
                    </div>
                </div>
            `;
      }

      // Toggle JSON display
      function toggleJson(element) {
        const container = element.parentElement;
        const jsonDisplay = container.querySelector(".json-display");

        element.classList.toggle("open");

        if (jsonDisplay.style.display === "none") {
          jsonDisplay.style.display = "block";
          element.querySelector(".toggle-icon").textContent = "‚ñº";
        } else {
          jsonDisplay.style.display = "none";
          element.querySelector(".toggle-icon").textContent = "‚ñ∂";
        }
      }

      // Download single metadata
      function downloadSingle(metadata) {
        const idMatch = metadata.name.match(/#(\d+)$/);
        const id = idMatch ? idMatch[1] : "1";
        const filename = `essay_${id}.json`;

        const dataStr = JSON.stringify(metadata, null, 2);
        const dataUri =
          "data:application/json;charset=utf-8," + encodeURIComponent(dataStr);

        const linkElement = document.createElement("a");
        linkElement.setAttribute("href", dataUri);
        linkElement.setAttribute("download", filename);
        linkElement.click();
      }

      // Download all metadata as JSON
      function downloadAll() {
        if (currentMetadata.length === 0) {
          alert("Please generate some metadata first!");
          return;
        }

        // Extract ID from the first metadata item's name
        const idMatch = currentMetadata[0].name.match(/#(\d+)$/);
        const id = idMatch ? idMatch[1] : "1";

        const dataStr = JSON.stringify(currentMetadata, null, 2);
        const dataUri =
          "data:application/json;charset=utf-8," + encodeURIComponent(dataStr);
        const exportFileDefaultName = `PixelMonsters-Story#${id}.json`;

        const linkElement = document.createElement("a");
        linkElement.setAttribute("href", dataUri);
        linkElement.setAttribute("download", exportFileDefaultName);
        linkElement.click();
      }

      // Handle URL parameters on load
      window.addEventListener("DOMContentLoaded", async () => {
        // Initialize blockchain connection
        const connected = await initBlockchain();
        
        if (!connected) {
          document.getElementById("metadataDisplay").innerHTML = 
            '<div style="text-align: center; padding: 40px; color: #ff6b6b;">Failed to connect to blockchain. Please refresh the page.</div>';
          return;
        }
        
        const urlParams = new URLSearchParams(window.location.search);
        const idFromUrl = urlParams.get("id");

        if (idFromUrl) {
          const id = parseInt(idFromUrl);
          if (id >= 1 && id <= 10000) {
            document.getElementById("idInput").value = id;
            await generateById();
          } else {
            await generateSingle();
          }
        } else {
          await generateSingle();
        }
      });
    </script>
  </body>
</html>
