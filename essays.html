<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Essay Collection - The Mythical Cursed-Nightmare</title>
    
    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <link rel="alternate icon" href="favicon.svg">
    
    <!-- Apple Touch Icon (180x180 for iOS) -->
    <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.svg" />
    
    <!-- PWA対応 -->
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    
    <!-- Additional Meta Tags -->
    <meta name="theme-color" content="#6B46C1">
    <meta name="description" content="Essay Collection - Legendary Tales from the Cursed Realm. Explore the complete anthology of generated essays.">
    
    <link rel="stylesheet" href="css/styles.css">
    <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
    
    <!-- Centralized Contract Configuration -->
    <script src="js/contracts-config.js"></script>
    <style>
      .stories-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
        gap: 20px;
        margin-top: 30px;
      }
      
      .story-card {
        background: rgba(107, 70, 193, 0.1);
        border: 1px solid rgba(107, 70, 193, 0.3);
        border-radius: 15px;
        padding: 20px;
        cursor: pointer;
        transition: all 0.3s ease;
        position: relative;
        overflow: hidden;
      }
      
      .story-card:hover {
        transform: translateY(-5px);
        box-shadow: 0 10px 30px rgba(147, 51, 234, 0.4);
        border-color: #A78BFA;
      }
      
      .story-card.legendary {
        background: linear-gradient(45deg, rgba(220, 38, 38, 0.2), rgba(239, 68, 68, 0.2));
        border-color: #EF4444;
      }
      
      .story-card.epic {
        background: linear-gradient(45deg, rgba(147, 51, 234, 0.2), rgba(167, 139, 250, 0.2));
        border-color: #A78BFA;
      }
      
      .story-card.rare {
        background: linear-gradient(45deg, rgba(59, 130, 246, 0.2), rgba(96, 165, 250, 0.2));
        border-color: #60A5FA;
      }
      
      .story-thumbnail {
        width: 100%;
        height: 150px;
        border-radius: 10px;
        object-fit: cover;
        margin-bottom: 15px;
      }
      
      div.story-thumbnail {
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
      }
      
      div.story-thumbnail svg {
        width: 100%;
        height: 100%;
        object-fit: contain;
      }
      
      .story-title {
        font-size: 1.3em;
        color: #E9D5FF;
        margin-bottom: 10px;
        font-weight: bold;
      }
      
      .story-excerpt {
        font-size: 0.9em;
        color: #C084FC;
        line-height: 1.4;
        display: -webkit-box;
        -webkit-line-clamp: 3;
        -webkit-box-orient: vertical;
        overflow: hidden;
      }
      
      .story-meta {
        margin-top: 15px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 0.8em;
        color: #9CA3AF;
      }
      
      .story-id {
        background: rgba(0, 0, 0, 0.3);
        padding: 4px 10px;
        border-radius: 15px;
      }
      
      .filter-controls {
        display: flex;
        gap: 15px;
        justify-content: center;
        margin: 20px 0;
        flex-wrap: wrap;
      }
      
      .filter-button {
        background: rgba(107, 70, 193, 0.2);
        border: 1px solid rgba(107, 70, 193, 0.3);
        padding: 8px 20px;
        border-radius: 20px;
        color: #C084FC;
        cursor: pointer;
        transition: all 0.3s;
        font-size: 14px;
      }
      
      .filter-button:hover {
        background: rgba(107, 70, 193, 0.3);
        color: #E9D5FF;
      }
      
      .filter-button.active {
        background: linear-gradient(45deg, #6B46C1, #9333EA);
        color: white;
        border-color: transparent;
      }
      
      .load-more {
        text-align: center;
        margin: 40px 0;
      }
      
      .story-badge {
        position: absolute;
        top: 10px;
        right: 10px;
        background: linear-gradient(45deg, #FFD700, #FFA500);
        color: #1a0033;
        padding: 4px 10px;
        border-radius: 15px;
        font-size: 0.7em;
        font-weight: bold;
      }
      
      .story-badge.legendary {
        background: linear-gradient(45deg, #DC2626, #EF4444);
        color: white;
      }
      
      @media (max-width: 768px) {
        .stories-grid {
          grid-template-columns: 1fr;
          gap: 15px;
        }
        
        .story-card {
          padding: 15px;
        }
        
        .story-thumbnail {
          height: 120px;
        }
        
        .story-title {
          font-size: 1.1em;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>Essay Collection</h1>
      <p style="font-size: 20px; color: #ddd; margin-top: 8px; text-align: center; font-weight: 500;">
        Legendary Tales from the Cursed Realm
      </p>
      <p style="font-size: 14px; color: #666; margin-top: 15px; text-align: center;">
        Explore the complete anthology of generated essays
      </p>
      
      <div class="button-group">
        <button onclick="window.location.href='generate.html'">← Back to Generator</button>
        <button onclick="loadRandomStories()" class="legendary-button">Load Random Essays</button>
      </div>
      
      <div class="filter-controls">
        <button class="filter-button active" onclick="filterStories('all')">All Essays</button>
        <button class="filter-button" onclick="filterStories('legendary')">Legendary</button>
        <button class="filter-button" onclick="filterStories('epic')">Epic</button>
        <button class="filter-button" onclick="filterStories('rare')">Rare</button>
        <button class="filter-button" onclick="filterStories('special')">Special Combos</button>
        <button class="filter-button" onclick="filterStories('own')">Own</button>
      </div>
      
      <div id="walletStatus" style="text-align: center; margin-top: 20px; display: none;">
        <button id="connectWalletBtn" onclick="connectWallet()" class="legendary-button">Connect Wallet</button>
        <p id="walletAddress" style="color: #A78BFA; margin-top: 10px;"></p>
      </div>
      
      <div id="storiesGrid" class="stories-grid">
        <!-- Stories will be dynamically loaded here -->
      </div>
      
      <div class="load-more">
        <button onclick="loadMoreStories()" class="nav-button">Load More Essays</button>
      </div>
      
      <footer style="text-align: center; margin-top: 40px; padding-top: 20px; color: #C084FC; font-size: 14px;">
        © 2025 The Mythical Cursed-Nightmare
      </footer>
    </div>

    <script>
      let currentFilter = 'all';
      let loadedStories = [];
      let displayCount = 12;
      let provider;
      let metadataBank;
      let blockchainConfig = null;
      let userAddress = null;
      let bankedNFTContract = null;
      let ownedTokenIds = [];
      
      // Load blockchain configuration
      async function loadBlockchainConfig() {
        // Try to use centralized config first
        if (typeof CONTRACTS_CONFIG !== 'undefined') {
          const network = CONTRACTS_CONFIG.getNetwork(21201); // Bon-Soleil Testnet
          if (network) {
            blockchainConfig = {
              networks: {
                bonsoleil: {
                  name: network.name,
                  rpcUrl: network.rpcUrl,
                  contracts: {
                    metadataBank: {
                      address: network.contracts.metadataBank,
                      abi: [
                        "function getMetadataCount() view returns (uint256)",
                        "function getMetadata(uint256 index) view returns (string)"
                      ]
                    },
                    bankedNFT: {
                      address: network.contracts.bankedNFT,
                      abi: [
                        "function balanceOf(address owner) view returns (uint256)",
                        "function tokenOfOwnerByIndex(address owner, uint256 index) view returns (uint256)",
                        "function ownerOf(uint256 tokenId) view returns (address)",
                        "function tokenURI(uint256 tokenId) view returns (string)"
                      ]
                    }
                  }
                }
              },
              defaultNetwork: "bonsoleil"
            };
            console.log('Using centralized contract configuration');
            return true;
          }
        }
        
        // Fallback to loading blockchain.json
        try {
          const response = await fetch('config/blockchain.json');
          if (response.ok) {
            blockchainConfig = await response.json();
            console.log('Blockchain configuration loaded from JSON');
            return true;
          }
        } catch (error) {
          console.log('Failed to load blockchain config, using defaults');
        }
        
        // Final fallback configuration
        blockchainConfig = {
          networks: {
            bonsoleil: {
              name: "Bon-Soleil Testnet",
              rpcUrl: "https://dev2.bon-soleil.com/rpc",
              contracts: {
                metadataBank: {
                  address: "0x565B793c191FE9C0D9980eCDB05A1471aBA198b4",
                  abi: [
                    "function getMetadataCount() view returns (uint256)",
                    "function getMetadata(uint256 index) view returns (string)"
                  ]
                },
                bankedNFT: {
                  address: "0xD8543363D99314fdE362014CF89CF6b5417d2B68",
                  abi: [
                    "function balanceOf(address owner) view returns (uint256)",
                    "function tokenOfOwnerByIndex(address owner, uint256 index) view returns (uint256)",
                    "function ownerOf(uint256 tokenId) view returns (address)",
                    "function tokenURI(uint256 tokenId) view returns (string)"
                  ]
                }
              }
            }
          },
          defaultNetwork: "bonsoleil"
        };
        return true;
      }
      
      // Initialize blockchain connection
      async function initBlockchain() {
        try {
          if (typeof ethers === 'undefined') {
            alert('ethers.js library not loaded. Please check your internet connection.');
            return false;
          }
          
          await loadBlockchainConfig();
          
          const network = blockchainConfig.networks[blockchainConfig.defaultNetwork];
          if (!network) {
            console.error('Network configuration not found');
            return false;
          }
          
          provider = new ethers.providers.JsonRpcProvider(network.rpcUrl);
          await provider.ready;
          
          const metadataBankConfig = network.contracts.metadataBank;
          metadataBank = new ethers.Contract(metadataBankConfig.address, metadataBankConfig.abi, provider);
          
          const bankedNFTConfig = network.contracts.bankedNFT;
          bankedNFTContract = new ethers.Contract(bankedNFTConfig.address, bankedNFTConfig.abi, provider);
          
          console.log(`Connected to ${network.name} at ${network.rpcUrl}`);
          console.log(`MetadataBank address: ${metadataBankConfig.address}`);
          console.log(`BankedNFT address: ${bankedNFTConfig.address}`);
          
          return true;
        } catch (error) {
          console.error('Failed to connect to blockchain:', error);
          return false;
        }
      }
      
      // Generate metadata from blockchain
      async function generateMetadataFromBlockchain(id) {
        try {
          const index = (id - 1) % 10000;
          let metadataUri = await metadataBank.getMetadata(index);
          
          // Check if the result is an address (proxy pattern)
          if (metadataUri.startsWith('0x') && metadataUri.length === 42) {
            console.log('MetadataBank returned an address:', metadataUri);
            const proxyMetadataBank = new ethers.Contract(
              metadataUri, 
              blockchainConfig.networks[blockchainConfig.defaultNetwork].contracts.metadataBank.abi, 
              provider
            );
            
            try {
              metadataUri = await proxyMetadataBank.getMetadata(index);
            } catch (proxyError) {
              console.error('Failed to get metadata from proxy contract:', proxyError);
              throw proxyError;
            }
          }
          
          // Decode the metadata
          let metadata;
          if (metadataUri.startsWith('data:application/json;base64,')) {
            const base64Json = metadataUri.replace('data:application/json;base64,', '');
            const jsonString = atob(base64Json);
            metadata = JSON.parse(jsonString);
          } else if (metadataUri.startsWith('{')) {
            metadata = JSON.parse(metadataUri);
          } else {
            throw new Error('Invalid metadata format');
          }
          
          // Add the ID to the metadata
          metadata.id = id;
          return metadata;
        } catch (error) {
          console.error('Error fetching from blockchain:', error);
          throw error;
        }
      }
      
      // Initialize with some random stories
      async function loadRandomStories() {
        const storiesGrid = document.getElementById('storiesGrid');
        storiesGrid.innerHTML = '<p style="text-align: center; color: #C084FC;">Loading essays from blockchain...</p>';
        
        if (!metadataBank) {
          storiesGrid.innerHTML = '<p style="text-align: center; color: #EF4444;">Blockchain connection not available. Please refresh the page.</p>';
          return;
        }
        
        loadedStories = [];
        const promises = [];
        
        // Generate 20 random essays
        for (let i = 0; i < 20; i++) {
          const randomId = Math.floor(Math.random() * 10000) + 1;
          promises.push(generateMetadataFromBlockchain(randomId));
        }
        
        try {
          loadedStories = await Promise.all(promises);
          displayStories();
        } catch (error) {
          storiesGrid.innerHTML = '<p style="text-align: center; color: #EF4444;">Failed to load essays from blockchain. Please try again.</p>';
        }
      }
      
      // Display stories based on current filter
      function displayStories() {
        const storiesGrid = document.getElementById('storiesGrid');
        storiesGrid.innerHTML = '';
        
        const filteredStories = filterStoriesByType(loadedStories, currentFilter);
        const storiesToShow = filteredStories.slice(0, displayCount);
        
        if (storiesToShow.length === 0) {
          storiesGrid.innerHTML = '<p style="text-align: center; color: #C084FC; grid-column: 1/-1;">No essays found for this filter.</p>';
          return;
        }
        
        storiesToShow.forEach(story => {
          const storyCard = createStoryCard(story);
          storiesGrid.appendChild(storyCard);
        });
      }
      
      // Filter stories by type
      function filterStoriesByType(stories, filter) {
        if (filter === 'all') return stories;
        
        if (filter === 'own') {
          // Filter to show only owned NFTs
          console.log('Filtering for owned NFTs. OwnedTokenIds:', ownedTokenIds);
          return stories.filter(story => {
            const tokenId = parseInt(story.id);
            const isOwned = ownedTokenIds.includes(tokenId);
            if (story.id <= 10) { // Log first 10 for debugging
              console.log(`Story ID: ${story.id}, TokenID: ${tokenId}, Owned: ${isOwned}`);
            }
            return isOwned;
          });
        }
        
        return stories.filter(story => {
          const rarity = story.attributes.find(a => a.trait_type === 'Rarity')?.value?.toLowerCase() || 'common';
          const isSpecial = story.attributes.find(a => a.trait_type === 'Special');
          
          switch(filter) {
            case 'legendary':
              return rarity === 'legendary';
            case 'epic':
              return rarity === 'epic';
            case 'rare':
              return rarity === 'rare';
            case 'special':
              return isSpecial;
            default:
              return true;
          }
        });
      }
      
      // Create story card element
      function createStoryCard(story) {
        const card = document.createElement('div');
        const rarity = story.attributes.find(a => a.trait_type === 'Rarity')?.value?.toLowerCase() || 'common';
        const isSpecial = story.attributes.find(a => a.trait_type === 'Special');
        const isLegendary = story.attributes.find(a => a.trait_type === 'Legendary');
        
        card.className = `story-card ${rarity}`;
        
        // Extract ID from name
        const idMatch = story.name.match(/#(\d+)$/);
        const storyId = idMatch ? idMatch[1] : '1';
        
        // Create badge HTML
        let badgeHtml = '';
        if (isLegendary) {
          badgeHtml = '<div class="story-badge legendary">⚡ LEGENDARY</div>';
        } else if (isSpecial) {
          badgeHtml = '<div class="story-badge">✨ SPECIAL</div>';
        }
        
        // Create image HTML with SVG support
        let imageHtml = '';
        if (story.image && story.image.startsWith('data:image/svg+xml;base64,')) {
          try {
            const base64Svg = story.image.replace('data:image/svg+xml;base64,', '');
            const svg = atob(base64Svg);
            // Wrap SVG in a div to control sizing
            imageHtml = `<div class="story-thumbnail">${svg}</div>`;
          } catch (e) {
            console.error('Failed to decode SVG:', e);
            // Fallback to img tag
            imageHtml = `<img src="${story.image}" alt="${story.name}" class="story-thumbnail">`;
          }
        } else {
          // For non-base64 SVG images, use img tag
          imageHtml = `<img src="${story.image}" alt="${story.name}" class="story-thumbnail">`;
        }
        
        card.innerHTML = `
          ${badgeHtml}
          ${imageHtml}
          <div class="story-title">${story.name}</div>
          <div class="story-excerpt">${story.description}</div>
          <div class="story-meta">
            <span class="story-id">ID: ${storyId}</span>
            <span>${rarity.charAt(0).toUpperCase() + rarity.slice(1)}</span>
          </div>
        `;
        
        card.onclick = () => {
          window.location.href = `generate.html?id=${storyId}`;
        };
        
        return card;
      }
      
      // Connect wallet function
      async function connectWallet() {
        if (typeof window.ethereum === 'undefined') {
          alert('Please install MetaMask to use this feature');
          return;
        }
        
        try {
          const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
          userAddress = accounts[0];
          
          document.getElementById('connectWalletBtn').style.display = 'none';
          document.getElementById('walletAddress').textContent = `Connected: ${userAddress.slice(0, 6)}...${userAddress.slice(-4)}`;
          
          // Load owned NFTs
          await loadOwnedNFTs();
        } catch (error) {
          console.error('Failed to connect wallet:', error);
          alert('Failed to connect wallet');
        }
      }
      
      // Load owned NFTs
      async function loadOwnedNFTs() {
        if (!userAddress || !bankedNFTContract) {
          console.log('Cannot load NFTs - userAddress:', userAddress, 'bankedNFTContract:', bankedNFTContract);
          return;
        }
        
        try {
          console.log('Loading NFTs for address:', userAddress);
          const balance = await bankedNFTContract.balanceOf(userAddress);
          console.log('Balance:', balance.toString());
          
          ownedTokenIds = [];
          
          // Use ERC721Enumerable tokenOfOwnerByIndex
          for (let i = 0; i < balance; i++) {
            try {
              const tokenId = await bankedNFTContract.tokenOfOwnerByIndex(userAddress, i);
              const tokenIdNumber = tokenId.toNumber();
              ownedTokenIds.push(tokenIdNumber);
              console.log(`Found owned token at index ${i}: ${tokenIdNumber}`);
            } catch (error) {
              console.error(`Error getting token at index ${i}:`, error);
            }
          }
          
          console.log(`User owns ${ownedTokenIds.length} NFTs:`, ownedTokenIds);
          
          // Load the metadata for owned NFTs
          if (ownedTokenIds.length > 0 && currentFilter === 'own') {
            await loadOwnedNFTsMetadata();
          }
        } catch (error) {
          console.error('Failed to load owned NFTs:', error);
          console.error('Error details:', error.message);
        }
      }
      
      // Load metadata for owned NFTs
      async function loadOwnedNFTsMetadata() {
        const promises = ownedTokenIds.map(tokenId => 
          generateMetadataFromBlockchain(tokenId)
        );
        
        try {
          const ownedStories = await Promise.all(promises);
          // Replace loadedStories with owned stories when viewing "own" filter
          if (currentFilter === 'own') {
            loadedStories = ownedStories;
            displayStories();
          }
        } catch (error) {
          console.error('Failed to load owned NFT metadata:', error);
        }
      }
      
      // Filter stories
      function filterStories(filter) {
        currentFilter = filter;
        displayCount = 12;
        
        // Update active button
        document.querySelectorAll('.filter-button').forEach(btn => {
          btn.classList.remove('active');
        });
        event.target.classList.add('active');
        
        // Show wallet connection status for "Own" filter
        const walletStatus = document.getElementById('walletStatus');
        if (filter === 'own') {
          walletStatus.style.display = 'block';
          if (!userAddress) {
            document.getElementById('storiesGrid').innerHTML = '<p style="text-align: center; color: #A78BFA;">Please connect your wallet to view your NFTs</p>';
            return;
          }
        } else {
          walletStatus.style.display = 'none';
        }
        
        displayStories();
      }
      
      // Load more stories
      function loadMoreStories() {
        displayCount += 12;
        displayStories();
      }
      
      // Load stories on page load
      window.addEventListener('DOMContentLoaded', async () => {
        // Initialize blockchain connection
        const connected = await initBlockchain();
        
        if (!connected) {
          document.getElementById('storiesGrid').innerHTML = 
            '<p style="text-align: center; color: #EF4444;">Failed to connect to blockchain. Please refresh the page.</p>';
          return;
        }
        
        loadRandomStories();
      });
    </script>
  </body>
</html>